

# Git



## 介绍

- **记录代码的历史版本**
  - 版本在迭代：更新；
  - 多个历史版本：旧版本有什么用？
  - 新开发v2：上线，测试遗漏问题，线上版本出问题；找到曾经v1稳定旧版本，先上线；
  - 方便多人协作开发（多个程序员做同样的项目），方便代码的自动化合并；

* 工具变化了解
  * 本地模式，不方便团队协作
  * 集中式（Svn），服务器如果出问题，就无法工作了（有安全问题）
  * 分布式（Git），既方便团队协作也比较安全



## 装配

### 安装

- [官方下载地址](https://git-scm.com/downloads)   双击，然后一直下一步即可完成安装
- 安装成功后，任意文件夹内鼠标右键，如果看到如下效果，证明安装成功

![image-20200615103028274](assets/image-20200615103028274.png)

### 配置

* 为何需要配置用户信息？未来要多人协作，需要确定代码是谁写的！

```bash
# --global 会将配置项保存到用户配置(提交代码需要用到这些信息，xxx换自己的名字和邮箱，随便写)
git config --global user.name "xxx"
git config --global user.email "xxx"

# 查看用户配置的信息
git config --list
```

- 如果没有配置用户信息，那么提交代码时会出现如下提示

![image-20200801165707414](assets/image-20200801165707414.png)

* git用户信息的配置位置`C:\Users\byte\.gitconfig`







## 初体验

- 打开：在某个有开发代码的文件夹或者是即将在该文件下写代码文件 下 打开的黑色命令窗口
- 初始化本地仓库：git 做历史版本记录；

```bash
git init
```

- 将文件添加到暂存区（临时存放代码的位置）【**一般代码做完一部分就添加一次**，也是必须的；】

```bash
# 把项目中所有的文件纳入git的管理  更新文件内容记录点；
git add 文件路径列表
```

- 提交暂存区代码到本地仓库（正式存放的位置）【一般是完成的阶段性任务可以提交一次，形成正式版本】

```bash
git commit -m '初始化版本'
```

- 查看提交的历史版本

```bash
git log
```









## 核心概念

### 代码  三个区域

- 工作目录：放置代码的项目的目录。**【注意：工作目录中新建的文件没有被git管理】**

![1605064138730](assets/1605064138730.png)

- 暂存区：临时管理代码的区域（尚未完成的功能代码一般添加到这里）。【只要代码添加到暂存区，那么就被git管理起来】
- 本地仓库：管理正式的代码的版本信息。【阶段性完成的小功能可以提交到本地仓库】

![1605065494275](assets/1605065494275.png)



### 文件四个状态

* `git status`
  
  - 未跟踪，新建的文件（红色的）
  
  ![1614219981447](assets/1614219981447.png)
  
  - 已暂存，添加到暂存区的文件（**绿色的文件**）
    - 第一次进入：new file
    - 工作区再次被修改更新到暂存区：modified 
  
  ![1614220204217](assets/1614220204217.png)
  
  - 已提交，本地仓库中的文件：没有什么颜色
  
  ![1614220481258](assets/1614220481258.png)
  
  - 工作目录代码被修改了（代码在）（红色的）
  
  ![1614220702557](assets/1614220702557.png)
  
  
  
  - 为什么要讲？
    - 通过看文件状态，知道现在git管理应该下一步操作说明命令？
    - day-01天：开发了很久，忘了现在是什么状态！
    - day-02上班：看下文件是什么状态！
    - git status 提示看到那些文件是新文件？那些文件被改了？需要进行历史提交？









## 基本流程

- 添加到暂存区：`git  add .   或者  git add ./a文件地址 ./b文件地址`
  - 新创建的文件就会被管理；
  - **一般在没有完成阶段性代码的时候，不要重复的对已经管理的文件，再次添加到暂存区；（后面解释）**

```bash
# 添加所有的文件到暂存区
git add . 

# 添加指定文件到暂存区 git add 文件列表（文件名称以空格隔开）
git add a.txt b.txt

# 添加所有文件到暂存区（但是排除以.开始的文件）
git add *
git add *.js
```

- 提交到本地仓库：
  - 什么情况下需要commit？完成了一个阶段性任务
  - 在正式commit之前，**必须更新暂存区记录点；`执行 git add .`**

```bash
  # 1.如果有新建的文件，必须先add再commit
  git add  文件
  git commit -m  '备注'
  
  # 2.如果当前的文件列表不包含新建的文件，可以按照如下方式提交
  git commit -a -m  "备注"
```

- 其他细节：了解

```bash
  # 修改提交的最后一次备注（可能最后一次备注写错了，需要修改这次备注）
  git commit --amend
  
  # 具体步骤：
  #   1、执行命令 git commit --amend
  #   2、在打开的窗口中按一下字符 【i】，那么就进入编辑状态（左下角出现插入两个字）
  #   3、此时就可以修改备注了，修改完成后按一下 【ESC】 按键，退出编辑状态
  #   4、英文输入法状态下，按 【shift】 和 【: 】 然后左下角出现光标
  #   5、输入【wq】，然后回车，完成编辑！
```

```bash
  # 提交代码时，不添加-m，那么会强制提示窗口填写备注
  git commit 
  # 1、执行上述命令后，会直接打开添加备注的窗口
  # 2、按一下 【i】 字符进入编辑状态
  # 3、输入备注信息，然后按 esc 键退出编辑模式
  # 4、在英文输入状态下，按 shift + : 然后左下角出现光标
  # 5、输入wq，完成提交
```



## 回撤操作

回滚 和 撤销：有人反悔了，想用过去记录！

### 回滚

* 场景：老板反悔了，回到上几个版本！
  * 下班前，已经提交一个历史版本，经过了测试！马上上线，绝对最新不妥，回到上几个版本代码！
  * **这个时候需要把代码回滚到上一个版本**
  * 需要：每次版本的提交的ID
* 动作：把当前版本  回滚 到 旧提交的版本；

```bash
# 查看历史版本的简化方式 ，前面的信息就是每次版本的ID值
git log --oneline

# git reset --hard commitID  回滚到指定的版本(用指定版本的代码覆盖工作目录和暂存区)
git reset --hard 615da1d
```

![1609569066798](assets/1609569066798.png)

* **回滚：从v3---->v1**
  * 回到过去版本，在v1不操作任何代码（回去看看曾经的版本），那么v2 v3版本还在！还能回到v3!
  * 在v3版本，修改代码，更新暂存区，提交一个新的版本；那么过去的v2 v3就被覆盖了；

* 回到过去：回到v1的时候，老板不可能不让我修改！那咋办？下午分支！







### 移出暂存区

- 场景：
  - 现在：我们在开发A  B模块，是不同的业务；现在A模块完成了，B模块也完成了！但是领导说先不要使用B模块。**也就是提交下次版本时，不能提交B模块的代码；**
    - 但是B模块已经在暂存区，只要修改就会被记录，
    - 那么根据文件记录点，也会被记录；那么提交也会被提交的。
    - **那么需要把  B模块  移出 暂存区；**
- 动作：把暂存区的某些文件再撤销到工作目录，那么git将不再管理记录该文件！**自己就可以手动删除！**相当于git add 的逆操作 （暂存区 -> 工作目录）

```bash
# 更新全部文件记录状态
git add . 

# 把某些文件移出暂存区，移出去后，提交本次仓储时，就不会对该文件进行提交；
git rm --cached 文件路径 文件路径

# 如果移出后，要继续提交
git commit -m "备注"
```

![1605068828965](assets/1605068828965.png)



### 撤销

* 一次大的ctrl+z操作：

* 场景：今天去上班，接到一个新的任务，花费了一个上午完成了60%（修改了10个文件），中午吃完饭，回来接着做，刚坐到工位，突然想到上午写思路错了，此时应该如何是好？**撤销所有的修改**

- 动作：本质上就是用暂存区修改前的代码覆盖当前工作目录的代码！

```bash
# 该命令执行时，一定要慎重的考虑好（撤销后，无法再找回）
git checkout .
git checkout ./A.html
```

* 注意这个撤销和回滚不一样：
  * 回滚：还能从过去回来
  * 撤销：真的撤销，回不来了！





## 远程仓储

### 介绍

* 本地仓库的代码上传到远程仓库，可以方便同事之间共享代码

* 公司内部一般有自己的远程仓库，但是学习阶段，可以借助公开一些远程仓库测试。
* 注册远程仓库账号：这些远程仓库都需要先注册账号才能使用
  * [github](https://github.com/)
  * [码云](https://gitee.com/)
  * [coding](https://coding.net/)



### 创建远程仓库

- 使用注册号的账号登录远程仓库平台
- 点击右上角的 + ，然后选择 new respository
- 在打开的界面中输入仓库名称（不能重复），其他选项默认

![1605078994574](assets/1605078994574.png)

- 然后点击底部的create repository按钮
- 跳转到一个新的页面，如下所示

![image-20200615153432322](assets/image-20200615153432322.png)

- 在本地仓储位置的 命令窗口执行：会出现提示框：输入用户名和密码；

![1605687310049](assets/1605687310049.png)

![1609501725432](assets/1609501725432.png)







### 配置用户权限

* 以后个人就要向公共仓储提交代码，提交时需要做用户名和密码验证；每次提交都必须得输入

- 熟悉ssh验证流程

![image-20200615154209928](assets/image-20200615154209928.png)

- 执行如下命令,生成公钥和私钥对

```bash
# ssh-keygen -t rsa -C '你的邮箱地址'
ssh-keygen -t rsa -C "wangzijie1031@qq.com"
```

![image-20200615154647208](assets/image-20200615154647208.png)

![image-20200615154900089](assets/image-20200615154900089.png)

- 把公钥提供给远程仓库：**右上角图标 ---> settings**

![image-20200615155043912](assets/image-20200615155043912.png)

- 点击New SSH key 按钮，然后打开一个表单，并且需要把公钥内容填充到key输入域当中，然后提交即可。

![1605079137592](assets/1605079137592.png)







### 推送【本地】到【远程】

* 场景：第一次提交

- 在本地 创建  远程仓库的别名

```bash
#   1.git remote add 别名 远程仓库地址
git remote add origin git@github.com:byte0/mydemo.git

#   2.本地仓库需要先commit代码然后才可以推送到远程
# 开发中...
# git commit -a -m 备注

#   3.第一次上传代码建议添加 -u,作用是把本地仓库和远程仓库关联，关联之后后续推动代码比较方便
git push -u origin master

#   4.后续上传代码可以进行如下简化
git push
```

- 出现如下图示，表示上传本地仓库代码到远程仓库成功！

![image-20200615155759742](assets/image-20200615155759742.png)

* 其他

```bash
# 修改别名(把origin修改为abc)
git remote rename origin abc
# 删除别名
git remote remove origin 
# 查看别名
git remote -v
```

* 向远程服务器推送代码时出现如下问题：
  * 原因：远程仓库的公钥没有配置成功
  * 解决：重新找公钥，然后把公钥设置到远程仓库即可！

![image-20200802155425943](assets/image-20200802155425943.png)





### 拉取【远程】到【本地】

* 场景：新员工刚入职，需要把公司已经上传到远程的代码克隆下拉继续开发

- 特别：你克隆我的代码，.git的版本管理记录也会被克隆下，但是你不能提交；

![1605080077193](assets/1605080077193.png)

```bash
# 克隆代码（把远程仓库的代码完整的复制一份到本地）
# git clone 远程仓库地址
git clone git@github.com:byte0/mydemo.git
```

- 已经克隆下来的项目代码需要更新最新代码：每次更新代码使用 git pull

```bash
# 更新远程仓库最新代码
git pull origin master

# 简写如下
git pull
```

* 全流程示意图：

![image-20200615164129858](assets/image-20200615164129858.png)





### 公司仓储

* 公司中一般都有自己的远程git仓库（在公司自己的服务器中）：GitLab
  * 公司中的git账号一般是分配的而不是注册的
  * 你需要把自己的公钥提供给领导
  * 权限配置成功后，你可以得到领导给你的仓库地址
  * 接下来你就可以得到公司的代码了
  * git clone 仓库地址









## 分支

### 概念

![1609571905509](assets/1609571905509.png)



* 分支：把代码复制一份新的就是一个新的分支（分支就是某一个版本代码的复制品）

- 测试项目时一般会以某一个分支为基准进行测试（测试分支）
- 有时代码出现了bug，此时可以创建一个单独的分支来修复bug（bug修复分支）



### 管理

* git log :  当前所在分支所有历史版本
* git status:  当前所在分支所有文件状态：

* 查看所有分支

```bash
# 查看当前所有本地分支
git branch
```

![image-20200616093329309](assets/image-20200616093329309.png)

* 创建分支  

```bash
# git branch 分支名称
#    1.创建分支时是以当前分支最后一个版本为基准
#    2.创建出来的分支是一份独立的代码
git branch test
```

* 切换分支

```bash
# git checkout 分支名称
#    1.切换分支后，当前工作目录中看到的代码就是新切换的分支的代码
#    2.切换分支时，需要先提交代码 git commit，就是先定一个版本；
git checkout test
```

* 创建并切换分支

```bash
# git checkout -b 分支名称
git checkout -b abc
```

* 删除分支

```bash
# git branch -d/-D 分支名称

#   如果test分支已经被合并了，那么才可以删除，否则无法删除
git branch -d test

#   强制删除分支，无论合并与否都会删除！
git branch -D test
```



### 普通合并

* 大前提：合并前，所有分支需要commit一个各自的版本！

- 普通合并：

```bash
# git merge 分支名（来源分支）  
#    1.【合并之前，两个分支不能再有代码的修改！代码都已经处于commit状态】 
#    2.在【当前分支master】把【另外一个分支（来源分支）demo】合并过来
git merge test
```

![image-20200616095038527](assets/image-20200616095038527.png)



### 冲突合并

* 冲突产生的原因：**不同分支的  【相同文件  的  相同位置】  的代码都做了修改**

- 冲突的窗口展示：

![1605082681725](assets/1605082681725.png)

- 冲突的代码展示：

![1605082755769](assets/1605082755769.png)

- 一旦产生冲突，没有合并成功；

![1605082856474](assets/1605082856474.png)

* 必须程序员自己解决，解决的原则是：保证两个分支的代码都合理；

![image-20200616103738879](assets/image-20200616103738879.png)





### 协作流程

* 远程仓库是共享的，所有项目研发者共享相同的远程仓库；
* **模式1：自己合并；**
  * 公司的业务在master主分支上；
  * 每个人开发的代码在本地**自己单独的分支上**；每个人先把远程的主分支master pull拉取下；
  * 拉取主分支代码，自己进行与主分支合并，解决冲突；
  * 与主分支合并完成，把主分支上代码推送到远程！
  * 注意：自己的分支没有推送到远程！

![1605084514289](assets/1605084514289.png)



* **模式2：专人合并**
  * 每个研发者有自己独有的分支，**开发者推送代码只能推送自己的分支；**
  * 专门有人负责合并研发者分支的代码到主分支；
  * 研发者下拉主分支代码，合并到自己分支上，继续开发；

![1605084967420](assets/1605084967420.png)







